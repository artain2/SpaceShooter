# SpaceShooter
Demo project with UniRX and binary serrialization

**Общее описание проекта:**
Игра состоит из двух экранов:
  1) Карта
  2) Сражение

  **_Карта_**
На всегда 3 планеты (уровня). Уровни открываются один за другим. В момент открытия уровня его параметры генерируются случайным образом, после чего сохраняются. После перезапуска уровень начнется с теми же параметрами, что и в прошлый раз. 
Запускать можно только открытые уровни. 
Открытый = белый
Закрытый = серый
После прохождения последнего уровня ничего не происходит.

  **_Сражение_**
Игрок - белая капсула, которая стреляет зелеными кружками. Управление сделано через клик: кораблик быстро перелетает в точку клика. Драгать кораблик нельзя.
Сверху вниз летят астероиды. Всего есть 4 типа астероидов:
1) обычный (желтый) - обычный астероид
2) Сложный (серый) - чуть больше и быстрее
3) Снежный ком (синий) - постепенно увеличивается
4) Дробящийся (фиолетовый) - мне лень было дописывать его логику, так что он тоже обычный

Если игрок попадает выстрелом в астероид, то астероид уничтожается
Если игрок качается астероида, то астероид уничтожается, а игрок теряет 1 жизнь
Если астероид достигает нижней части экрана, то самоуничтожается

Уровень считается проигранным, если у игрока закончились жизни
У игрока есть 3 жизни, после 3 столкновений с астероидами уровень считается проигранным. Игрок может выйти на карту или перезапустить уровень

Уровень считается выигранным, если закончилось время (сам не знаю зачем) и уничтожены все астероиды

  **_Параметры уровней_**
Уровни состоят из следующих параметров:
  - Время уровня
  - Количество астероидов
  - Наличие определенных типов астероидов
  - Вероятность появления каждого из типов астероидов


**Техническое описание проекта:**

  **_Используемые технологии_**
1) DI + Bootstrap
В проекте используется небольшой самописный DI. Вся логика выполняется в классах-сервисах. классы, помеченные аттрибутом [injectable] находятся по всей сборке и создаются по одному инстансу на класс, после чего инжектятся друг в друга

После того как все класы были созданы и заинжекчены начинается инициализация. В текущей реализации шаги инициализации выполняются последовательно, а методы инициализации запускаются паралельно. Таким образом загрузка происходит достаточно быстро, и не возникает ситуаций, когда один сервис запрашивает у другого еще непроиниченное поле.

Конфиг инжектора дополняется автоматически при обновлении сборки, но может быть изменен вручную
Управлять порядком инжектирования и инициализации можно в окне редактора (Ctrl+Shift+J)

2) UniRX 
Использую впервые. В основном для запусков таймеров и процессов растянух во времени. Управление UI через реактивные проперти непривычно и больше подходит для MVP чем для MVVC, которого я старался придерживаться.


  **_Сцены / экраны_**
Сцена одна. Она изначально пустая. вместо сцен исполдьзуются экраны - текущее состояние проекта. При смене экрана View сервисы загружают/выгружают или включают/выключают свои вьюхи

  **_Подгрузка ресурсов_**
На старте приложения сервыисы имеющие вьюхи подтягивают нужные им ассеты из ресурсов и, если нужно, сразу сознают их на сцене.

  **_UI_**
UI экрана создается сразу и целиком (здесь единственный экран - CoreUI.prefab). Вью сервисы просто запрашивают нужные им элементы из контейнера UIService

  **_Сохранение данных_**
Сервисы работающие с сохраняемыми данными расширяют интерфейс IDataService.
Через этот интерфейс они могут создать/отдать/принять серриализуемый объект.
DataService инжектит к себе все IDataService'ы и на этапе инициализации Load загружает файл с данными (бинарная серриализация) и приводит его к словарю, где ключ - это ID'шник IDataService, а значение - серриализованный объект с данными, после десерриализации каждому IDataService'у выдается соответствующий его ID объект. 
Если его объект не найден - запрашиваем у этого же сервиса пустой серриализуемый объект и отдаем этот объект сервису.

Сохранение вызывается принудительно в ключевых местах (победа на уровне)

  **_Конфиги_**
Их нет. не стал заморачиваться. Все данные забиты хардкодом в константные поля сервисов.
  
  **_Передача данных между сервисами_**
Сервисы инжектят к себе друг друга по интерфейсам (не обязательно). 
Если нужны все сервисы расширяющие интерфейс - инжектим коллекцию с нужным интерфейсом.
Обычно это используется вместо событийной системы, т.к. дает доступ к управлению порядкам обхода слушателей при вызове события. Интерфейсы слушателей заканчиваются на Sub (I____Sub).

  **_Основные сервисы и их зона ответственности_**
  - Общие
    -   DataService - загрузка / сохранение данных
    -   ScreenService - оповещение об изменении сцены
    -   GameRunner - входная точка
    -   UIService - Контейнер активных UI элементов
    -   UIRootService - Создает канвас
    -   CameraService - Доступ к камере
  - Map
    -   LevelProgressService - доступ к сохранению игрового прогресса по уровням
    -   LevelsSequenceService - информация о последовательности уровней
    -   MapViewService - ViewService планет (уровней). Слушает клики по планетам, запускает Core
  - Core
    -   InputController - Оповещает о кликах
    -   GameLoopService - набор инструкций при старте уровня
    -   ExitToMapService - кнопка выхода на карту
    -   CoreUIService - подгрузка UI кора
    -   AsteroidService - спавнит астероиды соответствующие текущему уровню (спавнит не сам, у каждого типа есть свой спавнер)
    -   LevelDataService - доступ к сохранению конфигурации уровня
    ---   LevelDataGenerator - генерирует случайные данные уровня на основе конфига
    -   LevelTimeService - Запускает таймер уровня
    ---   LevelTimeViewService - слушает LevelTimeService и обновляет вьюху таймера
    -   LoseService - набор инструкций при поражении
    ---   LoseWindowService - сервис вьюхи (окна)
    -   PlayerLiveService - слушает столкновения, считает жизни
    --- PlayerLiveViewService - вьюха жизней
    -   ShipProvider - создает кораблик в момент начала уровня
    -   ShipMotionService - перемещает кораблик в точку клика
    -   ShootingService - выпускает прожектайлы из корабля
    -   WinService - слушает время уровня и оставшиеся астероиды. Когда все пройдено - показывет окно победы
    ---   WinWindowService - вьюха окна

